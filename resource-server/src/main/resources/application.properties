# ===================================================================
# SERVER CONFIGURATION
# ===================================================================
# Configures the main server port for the application business API.
server.port=8081

# ===================================================================
# CORE APPLICATION CONFIGURATION
# ===================================================================
# Defines the application name, used for logging, service discovery, etc.
# The value is dynamically injected from the pom.xml's <artifactId> by Maven.
spring.application.name=@project.artifactId@

# ===================================================================
# MANAGEMENT & ACTUATOR CONFIGURATION
# ===================================================================
# Run the management endpoints (actuator) on a separate, dedicated port.
# This is a critical security practice to isolate sensitive operational endpoints
# from the public-facing application API.
management.server.port=9092

# Explicitly expose the actuator endpoints required for observability.
# "prometheus" is for metrics scraping by machine.
# "metrics", "health", and "info" are for operational checks and debugging.
management.endpoints.web.exposure.include=prometheus,metrics,health,info

# Enable the info contributor that reads "info.*" properties from the environment.
management.info.env.enabled=true

# ===================================================================
# MANAGEMENT & ACTUATOR SECURITY
# ===================================================================
# By defining these standard properties, Spring Boot's autoconfiguration
# will create a secure in-memory user, perfect for protecting the actuator
# endpoints with Basic Authentication. This is simpler than our previous
# custom AuthenticationProvider.
spring.security.user.name=${ACTUATOR_USERNAME}
spring.security.user.password=${ACTUATOR_PASSWORD}
spring.security.user.roles=${ACTUATOR_ROLES}

# ===================================================================
# SPRING SECURITY OAUTH2 RESOURCE SERVER
# ===================================================================
# This single property configures our application as an OAuth2 Resource Server.
# Spring Security will use this URI to:
#  1. Discover the OIDC configuration of the provider (Keycloak).
#  2. Fetch the provider's public keys (JWKS) to validate JWT signatures.
#  3. Automatically validate the issuer claim in incoming JWTs.
#
# We use the service name "keycloak" as the hostname, which is resolved by
# Docker's internal networking. Port 8080 is Keycloak's internal port.
spring.security.oauth2.resourceserver.jwt.issuer-uri=http://keycloak.local/realms/observability-lab

# ===================================================================
# APPLICATION METADATA (for info endpoint)
# ===================================================================
# These properties provide metadata about the application via the /actuator/info endpoint.
# The "@" symbols are automatically replaced by Maven during the build process via resource filtering.
info.app.name=@project.name@
info.app.description=@project.description@
info.app.version=@project.version@

# ===================================================================
# SPRING CLOUD VAULT CONFIGURATION
# ===================================================================
spring.config.import=vault://

# The configuration below uses a static, long-lived root token for authentication
# This is INSECURE and suitable ONLY for a simplified lab environment
#
# In a real-world production scenario, the recommended approach is to use the
# Vault AppRole authentication method. This involves:
# 1. Baking a non-sensitive "RoleID" into the application's configuration
# 2. Having a trusted orchestrator (like Kubernetes) securely generate and inject
#    a short-lived, single-use "SecretID" at application startup
#
# This solves the "first secret" problem without ever hardcoding long-lived
# credentials in the application's configuration
spring.cloud.vault.uri=http://vault:8200
spring.cloud.vault.token=dev-root-token

# Configuration for the Key-Value (KV) secrets engine.
spring.cloud.vault.kv.enabled=true
spring.cloud.vault.kv.backend=secret
# This uses the application name to look for secrets at the path "secret/resource-server"
spring.cloud.vault.kv.application-name=${spring.application.name}