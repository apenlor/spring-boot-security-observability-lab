# ===================================================================
# SERVER CONFIGURATION
# ===================================================================
server.port=8082

# ===================================================================
# CORE APPLICATION CONFIGURATION
# ===================================================================
# Defines the application name, used for logging, service discovery, etc.
# The value is dynamically injected from the pom.xml's <artifactId> by Maven.
spring.application.name=@project.artifactId@

# ===================================================================
# MANAGEMENT & ACTUATOR CONFIGURATION
# ===================================================================
# Run the management endpoints (actuator) on a separate, dedicated port.
management.server.port=9093

# Explicitly expose the actuator endpoints required for observability.
management.endpoints.web.exposure.include=prometheus,metrics,health,info

# Enable the info contributor that reads "info.*" properties from the environment.
management.info.env.enabled=true

# ===================================================================
# MANAGEMENT & ACTUATOR SECURITY
# ===================================================================
# These properties are sourced from Vault at startup. The keys must match what is written by populate-vault.sh.
spring.security.user.name=${actuator.username}
spring.security.user.password=${actuator.password}
spring.security.user.roles=${actuator.roles}

# ===================================================================
# SPRING SECURITY OAUTH2 CLIENT CONFIGURATION
# ===================================================================
# --- Provider Details ---
spring.security.oauth2.client.provider.keycloak-provider.issuer-uri=http://keycloak.local/realms/observability-lab

# --- Client Registration Details ---
# This value also forms the base for the full registration properties below.
oauth2.client.registration.id=lab-client
spring.security.oauth2.client.registration.lab-client.provider=keycloak-provider
# This must match the 'Client ID' we created in Keycloak ('web-app-client').
spring.security.oauth2.client.registration.lab-client.client-id=web-app-client
# The client secret is sourced from Vault
spring.security.oauth2.client.registration.lab-client.client-secret=${client-secret}
spring.security.oauth2.client.registration.lab-client.authorization-grant-type=authorization_code
# This must match one of the 'Valid Redirect URIs' configured in Keycloak.
# The {baseUrl}/{action}/oauth2/code/{registrationId} pattern is a Spring Security default.
spring.security.oauth2.client.registration.lab-client.redirect-uri={baseUrl}/login/oauth2/code/{registrationId}
# The scopes we request from Keycloak. 'openid' and 'profile' are standard for OIDC.
spring.security.oauth2.client.registration.lab-client.scope=openid,profile

# ===================================================================
# RESOURCE SERVER LOCATION
# ===================================================================
resource-server.url=http://resource-server:8081

# ===================================================================
# APPLICATION METADATA (for info endpoint)
# ===================================================================
# These properties provide metadata about the application via the /actuator/info endpoint.
# The "@" symbols are automatically replaced by Maven during the build process via resource filtering.
info.app.name=@project.name@
info.app.description=@project.description@
info.app.version=@project.version@

# ===================================================================
# SPRING CLOUD VAULT CONFIGURATION (Modern Approach)
# ===================================================================
spring.config.import=vault://

# The configuration below uses a static, long-lived root token for authentication
# This is INSECURE and suitable ONLY for a simplified lab environment
#
# In a real-world production scenario, the recommended approach is to use the
# Vault AppRole authentication method. This involves:
# 1. Baking a non-sensitive "RoleID" into the application's configuration
# 2. Having a trusted orchestrator (like Kubernetes) securely generate and inject
#    a short-lived, single-use "SecretID" at application startup
#
# This solves the "first secret" problem without ever hardcoding long-lived
# credentials in the application's configuration
spring.cloud.vault.uri=http://vault:8200
spring.cloud.vault.token=dev-root-token

# Configuration for the Key-Value (KV) secrets engine.
spring.cloud.vault.kv.enabled=true
spring.cloud.vault.kv.backend=secret
# This uses the application name to look for secrets at the path "secret/web-client".
spring.cloud.vault.kv.application-name=${spring.application.name}